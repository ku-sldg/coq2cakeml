Require Import CakeSem.SemanticsAux.
Require Import CakeSem.Evaluate.
Require Import RefineInv.
Require Import EvaluateDecsWrapper.
Declare ML Module "coq2cakeml:coq2cakeml.plugin".

Require Export RefineInv.
Require Export EvaluateDecsWrapper.
Require Export Equations.Prop.Equations.

(* Require Export ExampleInv. *)

(* Definition dummy_ffi_state (A : Type) (a : A) := *)
(*   let ffi_res := FFI.Oracle_return A a nil in *)
(*   let ffi_func := fun _ _ _ => ffi_res in *)
(*   let ffi_oracle := fun _ _ => ffi_func in *)
(*   FFI.initial_ffi_state (ffi_oracle a) a. *)

(* Definition init_st (A : Type) (a : A) : state A := *)
(*   {| clock := 0 *)
(*   ; refs  := empty_store *)
(*   ; ffi   := dummy_ffi_state A a *)
(*   ; next_type_stamp := 0 *)
(*   ; next_exn_stamp  := 0 |}. *)

(* Fresh Hell *)
(* Inductive void : Set := *)
(* Void : void -> void. *)

(* Fixpoint f (v : void) : nat := *)
(*   match v with *)
(*     Void v' => S (f v') *)
(*   end. *)

(* Inductive vec (A : Type) : nat -> Type := *)
(* | vnil : vec A 0 *)
(* | vcons : forall n, A -> vec A n -> vec A (S n). *)

(* GenerateInvariantAndUpdate vec. *)

(* Definition dumb_plus x y := let z := x + y in z. *)
(* Eval cbv in "Test 1: lambda, let in". *)
(* TranslateDefine dumb_plus. *)
(* Print cake_dumb_plus. *)

(* Definition list_test := [O]. *)
(* Eval cbv in "Test 2: 0 parameter constructor, 2 + 1 parameter constructor". *)
(* TranslateDefine list_test. *)
(* Print cake_list_test. *)

(* Eval cbv in "Test 3:". *)
(* Translate list. *)
(* TranslateDefine list. *)
(* Print cake_list. *)
(* (* Eval cbv in "Test 3: polymorphic, recursive function/fixpoint". *) *)
(* (* TranslateDefine map. *) *)
(* (* Print cake_map. *) *)

(* Eval cbv in "Test 4: polymorphic, recursive function/fixpoint and list invariant". *)
(* GenerateInvariant list. *)
(* Print list_INV. *)
(* TranslateDefine map. *)
(* Print cake_map. *)


(* Eval cbv in "Test: testing pattern generation". *)
(* PatTest list. *)
(* Require ExampleInv. *)
(* Ltac inv H := inversion H; subst; clear H. *)
(* Eval cbv in "Test 5: testing generatecertificate". *)

(* GenerateInvariantAndUpdate void. *)
(* Test void. *)
(* intros. destruct matched. *)
(* unfold EVAL in *; simpl. *)
(* intros. specialize (H2 st). *)
(* destruct H2 as [v [f [st' [Heval Hvoidinv]]]]. *)
(* inv Hvoidinv. *)
(* specialize (H3 matched x) with (st := st'). *)
(* destruct H2. *)
(* destruct H3 as [v' [f' [st'' [Heval' Hres]]]]; try reflexivity; try assumption. *)
(* eexists. *)
(* exists (list_max [f; f']). *)
(* eexists. *)
(* split. *)
(* unfold evaluate in *. *)
(* simp eval_or_match; simpl. *)
(* Check use_maximum_fuel. *)
(* apply use_maximum_fuel with (fuels := [f; f']) in Heval. *)
(* simpl in Heval. *)
(* rewrite Heval; simpl. *)
(* simp eval_or_match. *)
(* simpl. *)
(* simp pmatch; simpl. *)
(* inv H0. *)
(* destruct H5 as [con_name [ps [ty [HPcon [Hnodup [Hnslookup Hstamp]]]]]]. *)
(* inv HPcon. *)
(* simp pmatch; simpl. *)
(* rewrite Hnslookup; simpl. *)
(* simpl in Hstamp. *)
(* rewrite PeanoNat.Nat.eqb_eq in Hstamp. *)
(* rewrite Hstamp. *)
(* simpl. *)
(* simp pmatch. *)
(* clear H6 Hstamp Hnodup Hnslookup. *)
(* apply use_maximum_fuel with (fuels := [f; f']) in Heval'. *)
(* simpl in Heval'. *)
(* apply Heval'. *)
(* simpl; lia. *)
(* simpl; lia. *)
(* assumption. *)
(* Qed. *)

(* Require Import Nat. *)
(* GenerateInvariantAndUpdate nat. *)
(* Test nat. *)
(*   intros. *)
(*   destruct matched; *)
(*     unfold EVAL in *; unfold evaluate in *. *)
(*   - intros. *)
(*     specialize (H2 st). *)
(*     destruct H2 as [v [f [st' [H2 H2']]]]. *)
(*     clear H4. *)
(*     inv H2'. *)
(*     simp eval_or_match in H3. *)
(*     specialize H3 with (st := st'). *)
(*     destruct H3 as [v [f0 [st'0 [H3 H3']]]]; try reflexivity. *)
(*     exists v. *)
(*     exists (list_max [f;f0]). *)
(*     exists st'0. *)
(*     simp eval_or_match; simpl. *)
(*     apply (use_maximum_fuel [f;f0] _ f) in H2; simpl in H2. *)
(*     rewrite H2. simpl. *)
(*     simp eval_or_match; simpl. *)
(*     simp pmatch; simpl. *)
(*     unfold good_cons_env in H0. *)
(*     inv H0. *)
(*     destruct H5 as [con_name [ps [ty [H51 [H52 [H53 H54]]]]]]. *)
(*     inv H51. *)
(*     rewrite H53. *)
(*     simpl in H54. *)
(*     rewrite PeanoNat.Nat.eqb_eq in H54. *)
(*     subst. *)
(*     simpl. *)
(*     apply (use_maximum_fuel [f;f0] _ f0) in H3; simpl in H3; unfold list_max in H3. *)
(*     split. *)
(*     rewrite <- sem_env_id. *)
(*     unfold extend_dec_env in H3; simpl in H3. *)
(*     rewrite <- sem_env_id in H3. *)
(*     apply H3. *)
(*     assumption. *)
(*     unfold list_max; simpl; lia. *)
(*     unfold list_max; simpl; lia. *)
(*   - unfold evaluate in *. intros. *)
(*     specialize (H2 st). *)
(*     destruct H2 as [v [f [st' [H2 H2']]]]. *)
(*     clear H3. *)
(*     inv H2'. *)
(*     simp eval_or_match in H4. *)
(*     destruct H3 as [H31 H32]. *)
(*     specialize (H4 matched x). *)
(*     specialize H4 with (st := st'). *)
(*     destruct H4 as [v' [f0 [st'0 [H4 H4']]]]; try reflexivity; try assumption. *)
(*     exists v'. *)
(*     exists (list_max [f;f0]). *)
(*     exists st'0. *)
(*     simp eval_or_match; simpl. *)
(*     apply (use_maximum_fuel [f;f0] _ f) in H2; simpl in H2; try (simpl;lia). *)
(*     rewrite H2. simpl. *)
(*     simp eval_or_match; simpl. *)
(*     unfold good_cons_env in H0. *)
(*     inv H0; clear H0. *)
(*     simp pmatch; simpl. *)
(*     inv H6. *)
(*     clear H6 H7. *)
(*     destruct H3 as [con_name [ps [ty [H3' [H3_nodup [H3_lookup H3_stamp]]]]]]. *)
(*     destruct H5 as [con_name' [ps' [ty' [H5' [H5_nodup [H5_lookup H5_stamp]]]]]]. *)
(*     inv H3'. inv H5'. *)
(*     rewrite H5_lookup. *)
(*     simpl. *)
(*     simpl in H5_stamp. *)
(*     rewrite PeanoNat.Nat.eqb_eq in H5_stamp. rewrite H5_stamp; simpl. *)
(*     rewrite H3_lookup; simpl. *)
(*     simpl in H3_stamp. *)
(*     rewrite PeanoNat.Nat.eqb_eq in H3_stamp. subst. simpl. *)
(*     simp pmatch; simpl. *)
(*     split. *)
(*     unfold nsBind, extend_dec_env in H4; simpl in H4. *)
(*     apply more_fuel_same_value with f0. *)
(*     lia. *)
(*     apply H4. *)
(*     assumption. *)
(* Qed. *)

(* Definition f' (v : void) : nat := *)
(*   match v with Void v' => O end. *)
(* GenerateCertificate f'. *)
(* Proof. *)
(*   apply EVAL_EFun. *)
(*   intros. *)
(*   apply EVAL_EMat_void with (fun x => O) x. *)
(*   reflexivity. *)
(*   good_cons_env_solve. *)
(*   NoDup_solve. *)
(*   apply EVAL_EVar with v. *)
(*   unfold nsLookup; simpl; reflexivity. *)
(*   assumption. *)
(*   intros. *)
(*   eapply EVAL_ECon. *)
(*   instantiate (1 := []). reflexivity. *)
(*   unfold nsLookup. simpl. reflexivity. *)
(*   constructor. *)
(*   intros. *)
(*   inv H2. *)
(*   reflexivity. *)
(* Qed. *)

(* GenerateCertificate add. *)
(* Admitted. *)

(* GenerateCertificate id. *)
(* Proof. *)
(*   intros; apply EVAL_EFun. *)
(*   intros. eapply EVAL_EVar. *)
(*   simpl. *)
(*   unfold nsLookup; simpl; reflexivity. *)
(*   assumption. *)
(* Qed. *)

(* Definition dumb := add 1 1. *)
(* GenerateCertificate dumb. *)
(* Check EVAL_EApp_Opapp. *)
(* apply EVAL_EApp_Opapp with nat_INV. *)
(* - apply EVAL_EApp_Opapp with nat_INV. *)
(*   + eapply EVAL_ELetrec_EVAL_EVar. *)
(*     * apply cake_add_certificate_thm. *)
(*     * reflexivity. *)
(*   + eapply EVAL_ECon. *)
(*     instantiate (1 := [(nat_INV 0, ECon (Some (Short "O")) [])]); reflexivity. *)
(*     reflexivity. *)
(*     constructor. *)
(*     eapply EVAL_ECon. *)
(*     instantiate (1 := []); reflexivity. *)
(*     reflexivity. *)
(*     constructor. *)
(*     intros. *)
(*     inv H. *)
(*     reflexivity. *)
(*     constructor. *)
(*     intros. *)
(*     inv H. *)
(*     simpl. *)
(*     eexists. *)
(*     inv H4. *)
(*     split. *)
(*     reflexivity. *)
(*     reflexivity. *)
(* - eapply EVAL_ECon. *)
(*   instantiate (1 := [(nat_INV 0, ECon (Some (Short "O")) [])]); reflexivity. *)
(*   reflexivity. *)
(*   constructor. *)
(*   eapply EVAL_ECon. *)
(*   instantiate (1 := []); reflexivity. *)
(*   reflexivity. *)
(*   constructor. *)
(*   intros. *)
(*   inv H. *)
(*   reflexivity. *)
(*   constructor. *)
(*   intros. *)
(*   inv H. *)
(*   simpl. *)
(*   eexists. *)
(*   inv H4. *)
(*   split. *)
(*   reflexivity. *)
(*   reflexivity. *)
(* Qed. *)

(* GenerateInvariantAndUpdate bool. *)
(* Definition dumb (x : bool) := if x then 1 else 2. *)
(* GenerateCertificate dumb. *)

(* GenerateCertificate id. *)
(* Proof. *)
(*   intros; apply EVAL_EFun. *)
(*   intros. eapply EVAL_EVar. *)
(*   simpl. *)
(*   unfold nsLookup; simpl; reflexivity. *)
(*   assumption. *)
(* Qed. *)
(* Check cake_id_certificate_thm. *)

(* GenerateInvariantAndUpdate list. *)
(* Test list. *)
(*   intros. *)
(*   destruct matched; *)
(*     unfold EVAL in *; unfold evaluate in *. *)
(*   - intros. *)
(*     specialize (H2 st). *)
(*     destruct H2 as [v [f [st' [H2 H2']]]]. *)
(*     clear H4. *)
(*     inv H2'. *)
(*    simp eval_or_match in H3. *)
(*     assert (@nil PARAM0 = []) by reflexivity. *)
(*     specialize (H3 H st'). *)
(*     destruct H3 as [v [f0 [st'0 [H3 H3']]]]. *)
(*     clear H. *)
(*     exists v. *)
(*     exists (list_max [f;f0]). *)
(*     exists st'0. *)
(*     simp eval_or_match; simpl. *)
(*     apply (use_maximum_fuel _ [f;f0] _) in H2; simpl in H2. *)
(*     rewrite H2. simpl. *)
(*     simp eval_or_match; simpl. *)
(*     simp pmatch; simpl. *)
(*     unfold good_cons_env in H0. *)
(*     inv H0. *)
(*     destruct H5 as [con_name [ps [ty [H51 [H52 [H53 H54]]]]]]. *)
(*     inv H51. *)
(*     rewrite H53. *)
(*     simpl in H54. *)
(*     rewrite PeanoNat.Nat.eqb_eq in H54. *)
(*     subst. *)
(*     simpl. *)
(*     apply (use_maximum_fuel _ [f;f0] _) in H3; simpl in H3; unfold list_max in H3. *)
(*     split. *)
(*     rewrite <- sem_env_id. *)
(*     unfold extend_dec_env in H3; simpl in H3. *)
(*     rewrite <- sem_env_id in H3. *)
(*     apply H3. *)
(*     assumption. *)
(*     unfold list_max; simpl; lia. *)
(*     unfold list_max; simpl; lia. *)
(*   - unfold evaluate in *. intros. *)
(*     specialize (H2 st). *)
(*     destruct H2 as [v [f [st' [H2 H2']]]]. *)
(*     clear H3. *)
(*     inv H2'. *)
(*     simp eval_or_match in H4. *)
(*     assert (p::matched = p::matched) by reflexivity. *)
(*     destruct H3 as [v1 [H31 [H32 H33]]]. *)
(*     specialize (H4 p matched x v1 H H32 H33 st'). *)
(*     clear H. *)
(*     destruct H4 as [v' [f0 [st'0 [H4 H4']]]]. *)
(*     exists v'. *)
(*     exists (list_max [f;f0]). *)
(*     exists st'0. *)
(*     simp eval_or_match; simpl. *)
(*     apply (use_maximum_fuel _ [f;f0] _) in H2; simpl in H2; try (simpl;lia). *)
(*     rewrite H2. simpl. *)
(*     simp eval_or_match; simpl. *)
(*     unfold good_cons_env in H0. *)
(*     inv H0; clear H0. *)
(*     simp pmatch; simpl. *)
(*     inv H6. *)
(*     clear H6 H7. *)
(*     destruct H3 as [con_name [ps [ty [H3' [H3_nodup [H3_lookup H3_stamp]]]]]]. *)
(*     destruct H5 as [con_name' [ps' [ty' [H5' [H5_nodup [H5_lookup H5_stamp]]]]]]. *)
(*     inv H3'. inv H5'. *)
(*     rewrite H5_lookup. *)
(*     simpl. *)
(*     simpl in H5_stamp. *)
(*     rewrite PeanoNat.Nat.eqb_eq in H5_stamp. rewrite H5_stamp; simpl. *)
(*     destruct (string_eq_dec pat_str1 pat_str0). *)
(*     subst. *)
(*     inv H1. *)
(*     assert (In pat_str0 [pat_str0]) by (constructor; reflexivity). *)
(*     contradiction. *)
(*     rewrite <- eqb_neq in n. *)
(*     rewrite n; simpl. *)
(*     rewrite H3_lookup; simpl. *)
(*     inv H3_stamp. *)
(*     rewrite PeanoNat.Nat.eqb_eq in H0. *)
(*     subst. simpl. *)
(*     simp pmatch; simpl. *)
(*     split. *)
(*     unfold nsBind, extend_dec_env in H4; simpl in H4. *)
(*     apply more_fuel_same_value with f0. *)
(*     lia. *)
(*     apply H4. *)
(*     assumption. *)
(* Qed. *)

(* (* Definition dumb (A : Type) := [id A; id A]. *) *)
(* (* GenerateCertificate dumb. *) *)

(* Theorem EVAL_ECon_list_nil : *)
(*   forall A A_INV env, *)
(*     nsLookup ident_string_beq (Short "Nil") (sec env) = Some (0, TypeStamp "Nil" 0) -> *)
(*     EVAL env (ECon (Some (Short "Nil")) []) (list_INV A A_INV []). *)
(* Proof. *)
(*   intros A AINV env HnsLookup st. *)
(*   unfold evaluate. *)
(*   do 3 eexists. *)
(*   split. *)
(*   simp eval_or_match; simpl. *)
(*   rewrite HnsLookup; simpl. *)
(*   simp eval_or_match. *)
(*   unfold build_conv. *)
(*   unfold ident_string_beq in HnsLookup. *)
(*   rewrite HnsLookup. simpl. reflexivity. *)
(*   reflexivity. *)
(*   Unshelve. *)
(*   constructor. *)
(* Qed. *)

(* Theorem EVAL_ECon_list_Cons : *)
(*   forall A A_INV env a xs e1 e2, *)
(*     nsLookup ident_string_beq (Short "Cons") (sec env) = Some (2, TypeStamp "Cons" 0) -> *)
(*     EVAL env e1 (A_INV a) -> *)
(*     EVAL env e2 (list_INV A A_INV xs) -> *)
(*     EVAL env (ECon (Some (Short "Cons")) [e1;e2]) (list_INV A A_INV (a::xs)). *)
(* Proof. *)
(*   intros A AINV env a xs e1 e2 HnsLookup He1 He2. *)
(*   unfold EVAL, evaluate in *. *)
(*   intro st. *)
(*   specialize He2 with st. *)
(*   destruct He2 as [v2  [f2  [st2  [Hevale2 HINVe2]]]]. *)
(*   specialize He1 with st2. *)
(*   destruct He1 as [v1  [f1  [st1  [Hevale1 HINVe1]]]]. *)
(*   apply (more_fuel_same_value f1 (f1 + f2)) in Hevale1. *)
(*   apply (more_fuel_same_value f2 (f1 + f2)) in Hevale2. *)
(*   unfold evaluate in *. *)
(*   (* eexists. *) *)
(*   (* exists (f1 + f2). *) *)
(*   (* eexists. *) *)
(*   do 3 eexists. *)
(*   split. *)
(*   simp eval_or_match; simpl. *)
(*   rewrite HnsLookup; simpl. *)
(*   simp eval_or_match; simpl. *)
(*   rewrite Hevale2; simpl. *)
(*   rewrite Hevale1; simpl. *)
(*   unfold ident_string_beq in HnsLookup. *)
(*   rewrite HnsLookup; simpl. *)
(*   reflexivity. *)
(*   simpl. *)
(*   do 2 eexists. *)
(*   split. *)
(*   reflexivity. *)
(*   split; assumption. *)
(*   lia. *)
(*   lia. *)
(* Qed. *)

(* Require Import CakeSem.Evaluate. *)
(* GenerateCertificate map. *)
(* Obligations. *)
(*   intros A AINV B BINV. *)
(*   apply EVAL_EFun. *)
(*   intros f v H. *)
(*   apply EVAL_remove_EQ. *)
(*   - constructor. constructor. *)
(*   - intros x. *)
(*     apply EVAL_ELetrec. *)
(*     induction x. *)
(*     * intros u H'. *)
(*       apply EVAL_EMat_list with A AINV [] (fun a l => (f a)::(map f l)) []. *)
(*       + reflexivity. *)
(*       + good_cons_env_solve. *)
(*       + NoDup_solve. *)
(*       + apply EVAL_EVar with u; try reflexivity; try assumption. *)
(*       + intro. *)
(*         eapply EVAL_ECon_list_nil. *)
(*         reflexivity. *)
(*       + intros aa ab ac ad contra. *)
(*         inv contra. *)
(*     * intros u H'. *)
(*       apply EVAL_EMat_list with A AINV [] (fun a l => (f a)::(map f l)) (a::x). *)
(*       + reflexivity. *)
(*       + good_cons_env_solve. *)
(*       + NoDup_solve. *)
(*       + eapply EVAL_EVar; try reflexivity; try assumption. *)
(*       + intro contra. inv contra. *)
(*       + intros. *)
(*         eapply EVAL_ECon_list_Cons. *)
(*         -- reflexivity. *)
(*         -- eapply EVAL_EApp_Opapp. *)
(*            ** apply EVAL_EVar with v;try reflexivity; try assumption. *)
(*               apply H. *)
(*            ** eapply EVAL_EVar ; try reflexivity; try assumption. *)
(*         -- eapply EVAL_EApp_Opapp. *)
(*            ** eapply EVAL_EVar_Recclosure. *)
(*               ++ intros. *)
(*                  reflexivity. *)
(*               ++ apply IHx. *)
(*            ** eapply EVAL_EVar; try reflexivity; try assumption. *)
(*               unfold EQ. split; inv H0; try reflexivity; try assumption. *)
(* Qed. *)

(* FinishProgram "map". *)
(* Obligations. *)
(*   unfold DECL. *)
(*   eexists. *)
(*   simpl. *)
(*   simp evaluate_decs; simpl. *)
(*   simp evaluate_decs; simpl. *)
(*   simp eval_or_match; simpl. *)
(*   reflexivity. *)
(*   Unshelve. *)
(*   constructor. *)
(* Qed. *)

(* Check cake_prog_map_certificate_thm. *)

(* (* GenerateInvariantAndUpdate nat. *) *)
(* Fixpoint mymap (A B : Type) (f : A -> B) (l : list A) : list B := *)
(*   match l with *)
(*   | [] => [] *)
(*   | a :: t =>  f a :: mymap A B f t *)
(*   end. *)

(* Require Import CakeSem.Evaluate. *)
(* GenerateCertificate mymap. *)
(* Obligations. *)
(*   intros. *)
(*   apply EVAL_ELetrec_noEQ. *)
(*   intros. *)
(*   apply EVAL_remove_EQ. *)
(*   - constructor. constructor. *)
(*   - intros x. revert H. revert n v. induction x; intros. *)
(*     * apply EVAL_EFun; intros. *)
(*       apply EVAL_EMat_list with A A_INV [] (fun a l => (n a)::(mymap A B n l)) []. *)
(*       + inv H0. reflexivity. *)
(*       + good_cons_env_solve. *)
(*       + NoDup_solve. *)
(*       + eapply EVAL_EVar. *)
(*         reflexivity. *)
(*         apply exists_EQ_INV_iff_INV. *)
(*         exists []. *)
(*         inv H0. *)
(*         assumption. *)
(*       + intros. *)
(*         eapply EVAL_ECon. *)
(*         instantiate (1 := []). reflexivity. *)
(*         reflexivity. *)
(*         constructor. *)
(*         intros. *)
(*         inv H2. *)
(*         reflexivity. *)
(*       + intros. *)
(*         inv H1. *)
(*     * apply EVAL_EFun; intros. *)
(*       apply EVAL_EMat_list with A A_INV [] (fun a l => (n a)::(mymap A B n l)) (a::x). *)
(*       + inv H0. reflexivity. *)
(*       + good_cons_env_solve. *)
(*       + NoDup_solve. *)
(*       + eapply EVAL_EVar. *)
(*         reflexivity. *)
(*         apply exists_EQ_INV_iff_INV. *)
(*         exists (a::x). *)
(*         inv H0. *)
(*         assumption. *)
(*       + intros. *)
(*         inv H1. *)
(*       + intros. *)
(*         inv H1. *)
(*         eapply EVAL_ECon. *)
(*         instantiate (1 := *)
(*                        [(B_INV (n a_0), EApp Opapp [EVar (Short "f"); EVar (Short "a")]); *)
(*                         (list_INV B B_INV (mymap A B n a_1), EApp Opapp [EApp Opapp [EVar (Short "mymap"); EVar (Short "f")]; EVar (Short "t")])] *)
(*                     ). *)
(*         simpl. *)
(*         reflexivity. *)
(*         reflexivity. *)
(*         constructor. *)
(*         eapply EVAL_EApp_Opapp. *)
(*         eapply EVAL_EVar. *)
(*         reflexivity. *)
(*         apply H. *)
(*         eapply EVAL_EVar. *)
(*         reflexivity. *)
(*         assumption. *)
(*         constructor. *)
(*         eapply EVAL_EApp_Opapp. *)
(*         eapply EVAL_EApp_Opapp. *)
(*         eapply EVAL_EVar_Recclosure_noEQ. *)
(*         2 :{ reflexivity. } *)
(*         intros. *)
(*         { *)
(*           unfold build_rec_env in *; simpl in *. *)
(*           unfold bind_variable_name in *; unfold nsBind in *; simpl in *. *)
(*           unfold update_sev in *; simpl in *. *)
(*           apply IHx. *)
(*           apply H4. *)
(*         }. *)
(*         eapply EVAL_EVar. *)
(*         reflexivity. *)
(*         assumption. *)
(*         eapply EVAL_EVar. *)
(*         reflexivity. *)
(*         unfold EQ. *)
(*         split; try reflexivity; try assumption. *)
(*         constructor. *)
(*         intros. *)
(*         inv H4. *)
(*         inv H9. *)
(*         inv H11. *)
(*         simpl. *)
(*         do 2 eexists. *)
(*         split. reflexivity. *)
(*         split. *)
(*         assumption. *)
(*         assumption. *)
(* Qed. *)

(* Check cake_mymap_certificate_thm. *)

(* (*       induction x0. *) *)
(* (*       * simpl in H0. subst. *) *)
(* (*         unfold EVAL. intros. *) *)
(* (*         unfold evaluate. *) *)
(* (*         do 3 eexists. *) *)
(* (*         simp eval_or_match; simpl. *) *)
(* (*         split. *) *)
(* (*         reflexivity. *) *)
(* (*         reflexivity. *) *)
(* (*       * simpl in H0. *) *)
(* (*         destruct H0. *) *)
(* (*         destruct H0. *) *)
(* (*         destruct H0. *) *)
(* (*         subst. *) *)
(* (*         destruct H1. *) *)
(* (*         unfold EVAL. *) *)
(* (*         intros. *) *)
(* (*         do 3 eexists. *) *)
(* (*         unfold evaluate. *) *)
(* (*         simp eval_or_match; simpl. *) *)
(* (*         split. *) *)
(* (*         reflexivity. *) *)
(* (*         do 3 eexists. *) *)
(* (*         reflexivity. *) *)
(* (*         split; assumption. *) *)
(* (*     + intros; subst. inv H0. *) *)
(* (*       unfold EVAL. *) *)
(* (*       intros. *) *)
(* (*       do 3 eexists. *) *)
(* (*       unfold evaluate. *) *)
(* (*       simp eval_or_match; simpl. *) *)
(* (*       split; reflexivity. *) *)
(* (*     + intros; subst. *) *)
(* (*       eapply EVAL_ECon. *) *)
(* (*       (* instantiate (1 := [(fun v => True,EApp Opapp [EVar (Short "f"); EVar (Short "a")]); *) *) *)
(* (*       (*                    (fun v => True, EApp Opapp [EVar (Short "map"); EVar (Short "t")])]). *) *) *)
(* (*       instantiate (1 :=  [(B_INV (x x1), EApp Opapp [EVar (Short "f"); EVar (Short "a")]); *) *)
(* (*                          (list_INV B B_INV (map x xs), EApp Opapp [EVar (Short "map"); EVar (Short "t")])]). *) *)
(* (*       reflexivity. *) *)
(* (*       reflexivity. *) *)
(* (*       constructor. *) *)
(* (*       apply EVAL_EApp_Opapp with A_INV. *) *)
(* (*       apply EVAL_EVar with v; try reflexivity; try assumption. *) *)
(* (*       apply EVAL_EVar with v1; try reflexivity; try assumption. *) *)
(* (*       destruct H2. assumption. *) *)
(* (*       constructor. *) *)
(* (*       apply EVAL_EApp_Opapp with (list_INV A A_INV). *) *)
(* (*       eapply EVAL_EVar. *) *)
(* (*       reflexivity. *) *)
(* (*       unfold FUNC. intros. *) *)
(* (*       eexists. *) *)
(* (*       split. *) *)









(* (* Admitted. *) *)
(* (* GenerateCertificate List.length. *) *)
(* (* Obligations. *) *)
(* (* Admitted. *) *)
(* (* GenerateInvariantAndUpdate nat. *) *)
(* (* GenerateInvariantAndUpdate list. *) *)
(* (* GenerateInvariantAndUpdate prod. *) *)
(* (* Test list. *) *)

(* (* Test nat. *) *)
(* (* GenerateCertificate length. *) *)
(* (* GenerateCertificate plus. *) *)
(* (* GenerateInvariant prod. *) *)
(* (* GenerateCertificate fst. *) *)
(* (* Print cake_fst_certificate_thm. *) *)

(* (* Eval cbv in "Test 6: testing generatecertificate apps". *) *)
(* (* Definition x := fun (A B : Type) => @map (A*B) A fst. *) *)
(* (* (* Definition x (A B : Type) := @map (A*B) A fst. *) *) *)
(* (* GenerateCertificate x. *) *)



(* (* Eval cbv in "Test 4: polymorphic, recursive function/fixpoint". *) *)
(* (* TranslateDefine length. *) *)
(* (* Print cake_length. *) *)

(* (* Inductive list' (A B : Type) : Type := *) *)
(* (* | nil' : list' A B *) *)
(* (* | cons' : A * B -> list' A B -> list' A B. *) *)

(* (* Inductive color := Red | Green | Blue. *) *)
(* (* Eval cbv in "Test 1.1: stuff". *) *)
(* (* GenerateInvariant nat. *) *)
(* (* GenerateInvariant bool. *) *)
(* (* GenerateInvariant list. *) *)
(* (* GenerateInvariant prod. *) *)
(* (* GenerateInvariant color. *) *)
(* (* GenerateInvariant list'. *) *)
